# TopK 问题
## 少量数据，可以全部读入内存
LeetCode原题，两种方法：
1. 优先队列（堆排序）
2. QuickSelect

## 大量数据，无法全部读入内存
### 50 GB 数据，CPU 2 核，512 MB 内存
使用堆排序，内存中只需要常驻当前TopK，读取数据时只读取一个数据分组，比如 100 MB
### 50 GB 数据，CPU 2 核，2 GB 内存
1. 充分利用内存，读取数据时读取多个分组，比如 10 个；
2. 使用多线程在分组内部使用堆排序读取分组内的 TopK
3. 在10个TopK内使用QuickSelect得到本轮 TopK
4. 继续步骤 1

相比前一种方法，由于内存中数据变多，使用多线程查找TopK减少了总体运行时间。

## 超大量数据，多节点
### 100 TB 文件，200 节点
将100TB数据均分到 200 个结点上，节点内部使用多线程 + 组内堆排序 + QuickSelect 得到节点中数据的 TopK，然后将 200 个 TopK 全部放到一个节点，在单节点中查找最后的 TopK